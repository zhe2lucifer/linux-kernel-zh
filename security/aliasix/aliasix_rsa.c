/*
 *  ALi advanced security module
 *
 *  This file contains the ALi advanced verification implementations.
 *
 *  Author:
 *	Zhao Owen <owen.zhao@alitech.com>
 *
 *  Copyright (C) 2011 Zhao Owen <owen.zhao@alitech.com>
 *
 *	This program is free software; you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License version 2,
 *      as published by the Free Software Foundation.
 */

#include "aliasix_rsa.h"

/* Public key */
u8 aliasix_rsa_public_modulus[RSA_MAX_RSA_MODULUS_LEN] = {
    0xd3,0xc2,0x50,0xdd,0x9d,0x97,0x95,0x96,0xf2,0x11,0x5,0x46,0x33,0xa4,0x52,0xf1,
    0xc1,0xb7,0x7b,0xb4,0x36,0x7d,0xb9,0x5,0xa9,0x3d,0x81,0xb6,0x52,0xb8,0x23,0xf3,
    0x68,0x85,0xbc,0x61,0x9d,0x81,0x2d,0xb7,0x38,0x7d,0x60,0xf1,0x1f,0x40,0xe7,0xbf,
    0xae,0x29,0x60,0xea,0x8a,0x33,0x8f,0x17,0x5a,0x48,0x5e,0x9c,0x36,0xee,0xd,0x77,
    0xa6,0x47,0x2a,0xb4,0x91,0x3e,0x6a,0xdd,0x98,0x16,0x2b,0xb8,0x6a,0x6e,0x97,0x37,
    0xc9,0x7,0xf3,0x65,0x89,0xaa,0x60,0x30,0xa8,0xa,0xaf,0x30,0x54,0x5b,0x13,0xc9,0x60,
    0xd,0x5a,0xd5,0x2d,0x90,0xcc,0x48,0x17,0xbe,0xa5,0xac,0x40,0x24,0xff,0xc5,0x4f,0xeb,
    0xc0,0xc6,0x5e,0x3e,0x4d,0x52,0xa8,0x35,0xb2,0x20,0x74,0x24,0x37,0x21,0x18,0xec,0x49,
    0x86,0x9f,0x86,0x52,0x9e,0x10,0x27,0x71,0xe7,0x60,0x55,0xcb,0x9e,0x5f,0x35,0x28,0x46,
    0x75,0xea,0xe3,0x2b,0xb3,0x6f,0x2c,0xed,0x1a,0xfd,0x76,0xc1,0x4c,0x5,0x17,0x9d,0x98,
    0x8c,0x46,0x92,0xdb,0xd2,0x33,0x4a,0xf5,0x1c,0x4f,0x12,0x9d,0x3c,0x3d,0x4f,0x1d,0x30,
    0x93,0x56,0x36,0xcf,0xf0,0x89,0x19,0x8e,0x94,0x33,0xc,0x1c,0x25,0xd,0x85,0xf2,0x3,0xa9,
    0xe1,0xfe,0x29,0x43,0x72,0xac,0x88,0x17,0xdc,0xe0,0x18,0x90,0x44,0xd3,0x46,0x28,0x2b,
    0x73,0x67,0xa8,0xf8,0x63,0xb8,0x28,0x77,0x4d,0xfa,0xa3,0x9f,0xed,0x3c,0x6a,0x3b,0x6f,
    0xe7,0xd1,0x9d,0x35,0x9d,0xe7,0x0,0xd,0x40,0xf9,0xf9,0xd5,0xdf,0xad,0xce,0x5b,0x98,
    0xde,0x76,0x59,0x7b,0xb5};

u8 aliasix_rsa_public_exponent[RSA_MAX_RSA_MODULUS_LEN] = {
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,
    0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x0 ,0x1 ,0x0 ,0x1 };

/*
 * Useful MACROs
 */
#define ALIASIX_RSA_ATOH(result, str, condition, idx) \
    do { \
        result <<= 4; \
        if ((str[idx + 2] - '0') <= 9) \
	{ \
            result |= ((str[idx + 2] - '0') & 0x0000000F); \
	} \
        else \
	{ \
            result |= ((str[idx + 2] - 'a' + 10) & 0x0000000F); \
	} \
        idx++; \
    } while (condition)

/* Structure to accept data from U-Boot */
typedef struct _aliasix_rsa_public_key {
  unsigned int bits;                                    /* length in bits of modulus */
  unsigned char modulus[RSA_MAX_RSA_MODULUS_LEN];       /* modulus */
  unsigned char exponent[RSA_MAX_RSA_MODULUS_LEN];      /* public exponent */
} aliasix_rsa_public_key;

/*
 * To get the public key from U-Boot param
 * \@ param format:
 * \@             0x********,0x****
 * \@             addr(8 hex always),size
 */
static int __init aliasix_rsa_setup(char *str)
{
    char *rsa_opt = str;
    int i = 0;
    u_long addr = 0;
    u_long size = 0;
    aliasix_rsa_public_key *rsa_pub_key = NULL;

    ALIASIX_RSA("Info, signature param %s\n", str);

    if (NULL != strstr(str, "internal"))
        return 1;

    if (NULL == (rsa_opt = strstr(str, "0x")))
        return 0;

    ALIASIX_RSA_ATOH(addr, rsa_opt, (i < 8), i);

    if (NULL == (rsa_opt = strstr(str, ",")))
        return 0;
    if (NULL == (rsa_opt = strstr(rsa_opt, "0x")))
        return 0;

    i = 0;
    ALIASIX_RSA_ATOH(size, rsa_opt, (rsa_opt[i + 2] != '\0'), i);

    ALIASIX_RSA("Info, key addr 0x%x, len %d\n", addr, size);

    rsa_pub_key = (aliasix_rsa_public_key *)addr;

    ALIASIX_DUMP("Info, rsa modulus: ", rsa_pub_key->modulus, RSA_MAX_RSA_MODULUS_LEN);
    ALIASIX_DUMP("Info, rsa exponent: ", rsa_pub_key->exponent, RSA_MAX_RSA_MODULUS_LEN);

    memcpy(aliasix_rsa_public_modulus, rsa_pub_key->modulus, RSA_MAX_RSA_MODULUS_LEN);
    memcpy(aliasix_rsa_public_exponent, rsa_pub_key->exponent, RSA_MAX_RSA_MODULUS_LEN);
    
    return 1;
}

__setup("signature=", aliasix_rsa_setup);
